---
// AdaptiveTableOfContents.astro - 自适应目录组件
export interface Props {
  class?: string;
}

const { class: className } = Astro.props;
---

<!-- 桌面端侧边目录 -->
<aside
  id="table-of-contents"
  class:list={[
    "block", // 响应式显示：只在大屏幕显示
    "fixed z-40", // 固定定位
    "max-h-[calc(100vh-6rem)]",
    "lg:flex lg:max-h-[70vh] lg:flex-col lg:overflow-hidden", // 大屏：限制为视口70%并使子项可滚动
    "content-card rounded-lg p-4", // 卡片样式
    "transition-all duration-200 ease-out", // 基础过渡
    "shadow-md hover:shadow-lg", // 悬停阴影
    "translate-y-4 opacity-0", // 初始状态
    "will-change-transform", // 性能优化
    className,
  ]}
  style="width: 18rem;"
>
  <p class="mb-4 flex items-center gap-2 text-lg font-semibold text-accent">
    <svg
      class="h-5 w-5 text-accent"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"></path>
    </svg>
    目录
  </p>
  <nav
    class="toc-scrollbar relative max-h-[calc(100vh-12rem)] overflow-y-auto lg:max-h-full lg:min-h-0 lg:flex-1"
  >
    <!-- 移动的激活指示器 -->
    <div
      id="toc-active-indicator"
      class="pointer-events-none absolute left-0 z-0 w-full rounded-md border-l-2 border-accent/40 bg-accent/20 opacity-0 transition-all duration-300 ease-out"
      style="height: 0px; top: 0px;"
    >
    </div>
    <ul id="toc-list" class="relative z-10 space-y-1 text-sm">
      <!-- 加载状态 -->
      <li class="toc-loading animate-pulse">
        <div class="mb-2 h-4 w-3/4 rounded bg-muted/30"></div>
        <div class="mb-2 h-4 w-1/2 rounded bg-muted/20"></div>
        <div class="h-4 w-2/3 rounded bg-muted/30"></div>
      </li>
    </ul>
  </nav>
</aside>

<!-- 移动端浮动目录 -->
<div
  id="mobile-toc-float"
  class:list={[
    "block", // 只在小屏显示
    "fixed right-5 bottom-5 z-50", // 固定在右下角
    "rounded-xl backdrop-blur-lg", // 样式
    "font-mono text-foreground shadow-2xl", // 文字和阴影
    "transition-all duration-300 ease-in-out", // 动画
    "minimized overflow-hidden", // 初始最小化状态
    "translate-y-4 opacity-0", // 初始隐藏
    "flex flex-row-reverse items-end",
  ]}
>
  <!-- 最小化状态的按钮 -->
  <div
    id="toc-button"
    class="content-card group flex cursor-pointer items-center justify-center rounded-xl transition-all duration-200 hover:bg-accent/20"
    style="width: 3.5rem; height: 3.5rem;"
  >
    <svg
      class="text-accent transition-transform duration-200 group-hover:scale-110"
      style="width: 1.5rem; height: 1.5rem;"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"></path>
    </svg>
  </div>

  <!-- 展开状态的目录 -->
  <div
    id="toc-expanded"
    class="content-card hidden p-4"
    style="width: 18rem; max-height: 70vh;"
  >
    <!-- 头部控制区域 -->
    <div class="mb-4 flex items-center justify-between">
      <div class="flex items-center gap-2">
        <svg
          class="h-5 w-5 text-accent"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01"></path>
        </svg>
        <span class="text-lg font-semibold text-accent">目录</span>
      </div>
      <button
        id="toc-minimize-btn"
        class="flex items-center justify-center rounded-full bg-transparent opacity-70 transition-all duration-200 hover:bg-accent/20 hover:opacity-100"
        style="width: 2rem; height: 2rem;"
        aria-label="最小化目录"
      >
        <svg
          style="width: 1rem; height: 1rem;"
          viewBox="0 0 24 24"
          fill="currentColor"
        >
          <path d="M19 13H5v-2h14v2z"></path>
        </svg>
      </button>
    </div>

    <!-- 目录内容 -->
    <nav
      class="toc-scrollbar relative overflow-y-auto"
      style="max-height: calc(70vh - 6rem);"
    >
      <!-- 移动端激活指示器 -->
      <div
        id="mobile-toc-active-indicator"
        class="pointer-events-none absolute left-0 z-0 w-full rounded-md border-l-2 border-accent/40 bg-accent/20 opacity-0 transition-all duration-300 ease-out"
        style="height: 0px; top: 0px;"
      >
      </div>
      <ul id="mobile-toc-list" class="relative z-10 space-y-1 text-sm">
        <!-- 移动端加载状态 -->
        <li class="mobile-toc-loading animate-pulse">
          <div class="mb-2 h-4 w-3/4 rounded bg-muted/30"></div>
          <div class="mb-2 h-4 w-1/2 rounded bg-muted/20"></div>
          <div class="h-4 w-2/3 rounded bg-muted/30"></div>
        </li>
      </ul>
    </nav>
  </div>
</div>

<style>
  /* 浮动目录容器样式 - 参考MusicPlayer */
  #mobile-toc-float {
    background: rgba(var(--color-background) / 0.85);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(var(--color-border) / 0.3);
  }

  @media (prefers-color-scheme: dark) {
    html[data-theme="dark"] #mobile-toc-float {
      background: rgba(52, 63, 96, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
  }

  /* 最小化状态样式 */
  #mobile-toc-float.minimized {
    width: 3.5rem;
    height: 3.5rem;
  }

  #mobile-toc-float.minimized #toc-button {
    display: flex;
  }

  #mobile-toc-float.minimized #toc-expanded {
    display: none;
  }

  /* 展开状态样式 */
  #mobile-toc-float.expanded {
    width: 18rem;
    height: auto;
    max-height: 70vh;
  }

  #mobile-toc-float.expanded #toc-button {
    display: none;
  }

  #mobile-toc-float.expanded #toc-expanded {
    display: block;
  }

  /* 按钮尺寸 */
  .toc-button-size {
    width: 3.5rem;
    height: 3.5rem;
  }

  .toc-expanded-width {
    width: 18rem;
  }

  /* 展开动画增强 */
  #mobile-toc-float {
    transform-origin: bottom right;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* 按钮悬停效果增强 */
  #toc-button {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  #toc-button:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 25px rgba(var(--color-accent) / 0.3);
  }

  #toc-button:active {
    transform: scale(0.95);
  }

  /* 最小化按钮样式 */
  #toc-minimize-btn {
    transition: all 0.2s ease-out;
  }

  #toc-minimize-btn:hover {
    transform: scale(1.1);
    background: rgba(var(--color-accent) / 0.2) !important;
  }

  #toc-minimize-btn:active {
    transform: scale(0.9);
  }

  /* 目录内容过渡动画 - 参考MusicPlayer播放列表 */
  #toc-expanded {
    opacity: 0;
    transform: scale(0.9) translateY(10px);
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  #mobile-toc-float.expanded #toc-expanded {
    opacity: 1;
    transform: scale(1) translateY(0);
  }

  /* 目录项延迟动画 */
  .toc-item {
    transform: translateY(-10px);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  }

  #mobile-toc-float.expanded .toc-item {
    transform: translateY(0);
    opacity: 1;
  }

  /* 目录项延迟动画 - 逐个显示效果 */
  #mobile-toc-float.expanded .toc-item:nth-child(1) {
    transition-delay: 0.1s;
  }
  #mobile-toc-float.expanded .toc-item:nth-child(2) {
    transition-delay: 0.15s;
  }
  #mobile-toc-float.expanded .toc-item:nth-child(3) {
    transition-delay: 0.2s;
  }
  #mobile-toc-float.expanded .toc-item:nth-child(4) {
    transition-delay: 0.25s;
  }
  #mobile-toc-float.expanded .toc-item:nth-child(5) {
    transition-delay: 0.3s;
  }
  #mobile-toc-float.expanded .toc-item:nth-child(6) {
    transition-delay: 0.35s;
  }
  #mobile-toc-float.expanded .toc-item:nth-child(7) {
    transition-delay: 0.4s;
  }
  #mobile-toc-float.expanded .toc-item:nth-child(8) {
    transition-delay: 0.45s;
  }

  /* 脉冲效果 - 当有新内容时 */
  @keyframes pulse-glow {
    0% {
      box-shadow: 0 0 0 0 rgba(var(--color-accent) / 0.4);
    }
    70% {
      box-shadow: 0 0 0 10px rgba(var(--color-accent) / 0);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(var(--color-accent) / 0);
    }
  }

  #toc-button.pulse {
    animation: pulse-glow 1.5s infinite;
  }

  /* 入场动画 */
  .animate-fadeInUp {
    animation: fadeInUp 0.6s ease-out forwards;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(1rem);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<script>
  let cleanupAdaptiveToc: (() => void) | null = null;

  const createRafScheduler = (callback: () => void) => {
    let ticking = false;
    return () => {
      if (ticking) return;
      ticking = true;
      requestAnimationFrame(() => {
        ticking = false;
        callback();
      });
    };
  };

  function initAdaptiveTableOfContents() {
    cleanupAdaptiveToc?.();

    const controller = new AbortController();
    const { signal } = controller;

    const tocContainer = document.getElementById("table-of-contents");
    const tocList = document.getElementById("toc-list");

    const mobileFloat = document.getElementById("mobile-toc-float");
    const tocButton = document.getElementById("toc-button");
    const tocExpanded = document.getElementById("toc-expanded");
    const minimizeBtn = document.getElementById("toc-minimize-btn");
    const mobileTocList = document.getElementById("mobile-toc-list");

    if (!tocContainer || !tocList || !mobileFloat) {
      cleanupAdaptiveToc = () => controller.abort();
      return;
    }

    const tocContainerEl = tocContainer as HTMLElement;
    const tocListEl = tocList as HTMLUListElement;
    const mobileFloatEl = mobileFloat as HTMLElement;
    const mobileTocListEl = mobileTocList as HTMLUListElement | null;

    const article = document.getElementById("article");
    if (!article) {
      cleanupAdaptiveToc = () => controller.abort();
      return;
    }

    const headings = article.querySelectorAll("h2, h3, h4, h5, h6");

    const loadingElement = tocListEl.querySelector(".toc-loading");
    if (loadingElement) {
      loadingElement.remove();
    }

    if (mobileTocListEl) {
      const mobileLoadingElement = mobileTocListEl.querySelector(
        ".mobile-toc-loading"
      );
      if (mobileLoadingElement) {
        mobileLoadingElement.remove();
      }
    }

    if (headings.length === 0) {
      tocContainerEl.style.display = "none";
      mobileFloatEl.style.display = "none";
      cleanupAdaptiveToc = () => controller.abort();
      return;
    }

    type TocItem = {
      level: number;
      text: string;
      id: string;
      element: HTMLHeadingElement;
    };

    const tocItems: TocItem[] = Array.from(headings).map((heading, index) => {
      const headingElement = heading as HTMLHeadingElement;
      const level = parseInt(headingElement.tagName.charAt(1));
      let text = "";

      for (const node of headingElement.childNodes) {
        if (node.nodeType === Node.TEXT_NODE) {
          text += node.textContent || "";
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const element = node as Element;
          if (element.tagName && element.tagName.toLowerCase() !== "a") {
            text += element.textContent || "";
          }
        }
      }

      text = text.trim();

      if (!text) {
        text = headingElement.textContent?.trim() || "";
        text = text.replace(/\s*#\s*$/, "");
      }

      const id = headingElement.id || `heading-${index}`;
      if (!headingElement.id) {
        headingElement.id = id;
      }

      return {
        level,
        text,
        id,
        element: headingElement,
      };
    });

    const getIndentClass = (level: number) => {
      switch (level) {
        case 2:
          return "pl-3";
        case 3:
          return "pl-6";
        case 4:
          return "pl-9";
        case 5:
          return "pl-12";
        case 6:
          return "pl-15";
        default:
          return "pl-3";
      }
    };

    const generateTocHTML = () =>
      tocItems
        .map(
          item => `
          <li class="transition-all duration-200 toc-item relative" data-level="${item.level}">
            <a 
              href="#${item.id}" 
              class="block ${getIndentClass(item.level)} py-2 px-3 text-muted-foreground no-underline rounded-md transition-all duration-50 hover:text-accent toc-link relative z-10" 
              data-target="${item.id}"
            >
              ${item.text}
            </a>
          </li>
        `
        )
        .join("");

    const tocHTML = generateTocHTML();
    tocListEl.innerHTML = tocHTML;
    if (mobileTocListEl) {
      mobileTocListEl.innerHTML = tocHTML;
    }

    const articleCard = document.querySelector("article.content-card") as
      | HTMLElement
      | null;

    const headingPositions = new Array<number>(tocItems.length).fill(0);
    const activeState = new Map<Element, string>();

    const cacheHeadingPositions = () => {
      for (let i = 0; i < tocItems.length; i++) {
        const rect = tocItems[i].element.getBoundingClientRect();
        headingPositions[i] = rect.top + window.scrollY;
      }
    };

    const ensureActiveItemVisible = (container: Element, activeId: string) => {
      if (!activeId) return;
      const activeLink = container.querySelector(
        `.toc-link[data-target="${CSS.escape(activeId)}"]`
      ) as HTMLElement | null;
      if (!activeLink) return;
      activeLink.scrollIntoView({
        block: "nearest",
        inline: "nearest",
        behavior: "smooth",
      });
    };

    function updateTocActiveState(
      container: Element,
      indicatorId: string,
      activeId: string
    ) {
      const prevActiveId = activeState.get(container);
      if (prevActiveId === activeId) return;

      if (prevActiveId) {
        const prevLink = container.querySelector(
          `.toc-link[data-target="${CSS.escape(prevActiveId)}"]`
        ) as HTMLElement | null;
        if (prevLink) {
          prevLink.classList.add("text-muted-foreground");
          prevLink.classList.remove("text-accent", "font-medium");
        }
      } else {
        const allLinks = container.querySelectorAll(".toc-link");
        allLinks.forEach(link => {
          link.classList.add("text-muted-foreground");
          link.classList.remove("text-accent", "font-medium");
        });
      }

      let activeLiElement: HTMLElement | null = null;
      if (activeId) {
        const nextLink = container.querySelector(
          `.toc-link[data-target="${CSS.escape(activeId)}"]`
        ) as HTMLElement | null;
        if (nextLink) {
          nextLink.classList.remove("text-muted-foreground");
          nextLink.classList.add("text-accent", "font-medium");
          activeLiElement = nextLink.parentElement as HTMLElement;
        }
      }

      const indicator = document.getElementById(indicatorId);
      const firstLi = container.querySelector("li") as HTMLElement | null;

      if (indicator && activeLiElement && firstLi) {
        const liRect = activeLiElement.getBoundingClientRect();
        const firstRect = firstLi.getBoundingClientRect();
        indicator.style.top = `${liRect.top - firstRect.top}px`;
        indicator.style.height = `${liRect.height}px`;
        indicator.style.opacity = "1";
      } else if (indicator) {
        indicator.style.opacity = "0";
      }

      activeState.set(container, activeId);
    }

    function updateActiveHeading() {
      if (!tocItems.length && tocContainer?.classList.contains("expanded")) return;

      const windowHeight = window.innerHeight;
      const scrollTop = window.scrollY;
      const activationPoint = scrollTop + windowHeight / 3 + 4;
      let low = 0;
      let high = headingPositions.length - 1;
      let bestIndex = -1;

      while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        if (headingPositions[mid] <= activationPoint) {
          bestIndex = mid;
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }

      const isNearBottom =
        scrollTop + windowHeight >= document.documentElement.scrollHeight - 100;

      let activeId = bestIndex >= 0 ? tocItems[bestIndex].id : "";
      if (isNearBottom && !activeId && tocItems.length > 0) {
        activeId = tocItems[tocItems.length - 1]?.id ?? "";
      }

      updateTocActiveState(tocListEl, "toc-active-indicator", activeId);
      ensureActiveItemVisible(tocListEl, activeId);

      if (mobileTocListEl) {
        updateTocActiveState(
          mobileTocListEl,
          "mobile-toc-active-indicator",
          activeId
        );
        ensureActiveItemVisible(mobileTocListEl, activeId);
      }
    }

    function adjustTocPosition() {
      if (!articleCard) return;

      const articleRect = articleCard.getBoundingClientRect();
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      const articleRight = articleRect.right;
      const availableSpace = windowWidth - articleRight;
      const minSpaceForSidebar = 280 + 16;

      if (availableSpace >= minSpaceForSidebar) {
        tocContainerEl.style.visibility = "visible";
        tocContainerEl.style.left = `${articleRight + 16}px`;
        tocContainerEl.style.right = "auto";
        tocContainerEl.style.opacity = "100";
        mobileFloatEl.style.opacity = "0";
        mobileFloatEl.classList.add("mobileFloatHidden");
        mobileFloatEl.classList.remove("mobileFloatVisible");
      } else {
        tocContainerEl.style.opacity = "0";
        tocContainerEl.style.visibility = "hidden";
        mobileFloatEl.style.opacity = "100";
        mobileFloatEl.style.visibility = "visible";
        mobileFloatEl.classList.add("mobileFloatVisible");
        mobileFloatEl.classList.remove("mobileFloatHidden");
      }

      const articleTop = articleRect.top;
      let targetTop = articleTop >= 16 ? articleTop : 16;

      const tocHeight = tocContainerEl.offsetHeight;
      const maxTop = windowHeight - tocHeight - 20;
      targetTop = Math.min(targetTop, maxTop);

      tocContainerEl.style.top = `${targetTop}px`;
      tocContainerEl.style.position = "fixed";
    }

    const scheduleScrollUpdate = createRafScheduler(() => {
      updateActiveHeading();
      adjustTocPosition();
    });

    const scheduleResizeUpdate = createRafScheduler(() => {
      cacheHeadingPositions();
      updateActiveHeading();
      adjustTocPosition();
    });

    const addClickEvents = (container: Element, shouldMinimize = false) => {
      const tocLinks = container.querySelectorAll(".toc-link");
      tocLinks.forEach(link => {
        link.addEventListener(
          "click",
          event => {
            event.preventDefault();
            const targetId = link.getAttribute("data-target");
            const targetElement = targetId
              ? document.getElementById(targetId)
              : null;

            if (targetElement) {
              if (shouldMinimize) {
                mobileFloatEl.classList.remove("expanded");
                mobileFloatEl.classList.add("minimized");
              }

              const windowHeight = window.innerHeight;
              const targetTop =
                targetElement.getBoundingClientRect().top + window.scrollY;
              const offsetTop = targetTop - windowHeight / 3;

              setTimeout(() => {
                window.scrollTo({
                  top: Math.max(0, offsetTop),
                  behavior: "smooth",
                });
              }, shouldMinimize ? 200 : 0);

              setTimeout(() => {
                history.pushState(null, "", `#${targetId}`);
              }, shouldMinimize ? 300 : 100);
            }
          },
          { signal }
        );
      });
    };

    addClickEvents(tocListEl, false);
    if (mobileTocListEl) {
      addClickEvents(mobileTocListEl, true);
    }

    let mutationObserver: MutationObserver | null = null;
    if (mobileTocListEl && tocButton) {
      const addPulseEffect = () => {
        tocButton.classList.add("pulse");
        setTimeout(() => {
          tocButton.classList.remove("pulse");
        }, 3000);
      };

      mutationObserver = new MutationObserver(() => {
        if (mobileFloatEl.classList.contains("minimized")) {
          addPulseEffect();
        }
        scheduleResizeUpdate();
      });

      mutationObserver.observe(mobileTocListEl, {
        childList: true,
        subtree: true,
      });
    }

    if (tocButton && tocExpanded && minimizeBtn) {
      const expandToc = () => {
        mobileFloatEl.classList.remove("minimized");
        mobileFloatEl.classList.add("expanded");
        setTimeout(() => {
          updateActiveHeading();
        }, 300);

        setTimeout(() => {
          const tocItems = mobileTocListEl?.querySelectorAll(".toc-item");
          tocItems?.forEach((item, index) => {
            (item as HTMLElement).style.transitionDelay = `${0.1 + index * 0.05}s`;
          });
        }, 50);

        scheduleResizeUpdate();
      };

      const minimizeToc = () => {
        mobileFloatEl.classList.remove("expanded");
        mobileFloatEl.classList.add("minimized");

        const tocItems = mobileTocListEl?.querySelectorAll(".toc-item");
        tocItems?.forEach(item => {
          (item as HTMLElement).style.transitionDelay = "0s";
        });
      };

      tocButton.addEventListener(
        "click",
        event => {
          event.stopPropagation();
          expandToc();
        },
        { signal }
      );

      minimizeBtn.addEventListener(
        "click",
        event => {
          event.stopPropagation();
          minimizeToc();
        },
        { signal }
      );

      document.addEventListener(
        "click",
        event => {
          if (
            !mobileFloat.contains(event.target as Node) &&
            mobileFloat.classList.contains("expanded")
          ) {
            minimizeToc();
          }
        },
        { signal }
      );

      document.addEventListener(
        "keydown",
        event => {
          if (
            event.key === "Escape" &&
            mobileFloat.classList.contains("expanded")
          ) {
            minimizeToc();
          }
        },
        { signal }
      );
    }

    window.addEventListener("scroll", scheduleScrollUpdate, {
      passive: true,
      signal,
    });
    window.addEventListener("resize", scheduleResizeUpdate, { signal });
    window.addEventListener("orientationchange", scheduleResizeUpdate, {
      signal,
    });
    window.addEventListener(
      "load",
      () => {
        scheduleResizeUpdate();
      },
      { once: true, signal }
    );

    let resizeObserver: ResizeObserver | null = null;
    if (articleCard) {
      resizeObserver = new ResizeObserver(() => {
        scheduleResizeUpdate();
      });
      resizeObserver.observe(articleCard);
    }

    cacheHeadingPositions();
    updateActiveHeading();
    adjustTocPosition();

    requestAnimationFrame(() => {
      cacheHeadingPositions();
      updateActiveHeading();
      adjustTocPosition();
    });

    setTimeout(() => {
      tocContainerEl.classList.remove("opacity-0", "translate-y-4");
      tocContainerEl.classList.add("opacity-100", "translate-y-0");
      adjustTocPosition();

      mobileFloatEl.classList.remove("opacity-0", "translate-y-4");
      mobileFloatEl.classList.add(
        "opacity-100",
        "translate-y-0",
        "animate-bounce-in"
      );

      setTimeout(() => {
        mobileFloatEl.classList.remove("animate-bounce-in");
      }, 600);

      setTimeout(updateActiveHeading, 200);
    }, 50);

    cleanupAdaptiveToc = () => {
      controller.abort();
      mutationObserver?.disconnect();
      resizeObserver?.disconnect();
    };
  }

  document.addEventListener("DOMContentLoaded", initAdaptiveTableOfContents);
  document.addEventListener("astro:after-swap", initAdaptiveTableOfContents);
  document.addEventListener("astro:page-load", initAdaptiveTableOfContents);
</script>
