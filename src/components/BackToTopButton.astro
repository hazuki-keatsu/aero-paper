---
import IconChevronLeft from "@/assets/icons/IconChevronLeft.svg";
---

<!-- 回到顶部按钮（样式参考 MusicPlayer 最小化按钮） -->
<div
  id="btt-btn-container"
  transition:persist="back-to-top"
  class="fixed right-5 bottom-24 z-40 translate-y-14 opacity-0 transition-all duration-200 ease-in-out"
>
  <button
    type="button"
    data-button="back-to-top"
    aria-label="返回顶部"
    class="content-card group flex cursor-pointer items-center justify-center rounded-xl transition-all duration-200 hover:bg-accent/20"
    style="width: 3.5rem; height: 3.5rem;"
  >
    <IconChevronLeft
      aria-hidden="true"
      class="rotate-90 text-accent transition-transform duration-200 group-hover:scale-110"
      style="width: 1.5rem; height: 1.5rem;"
    />
  </button>
</div>

<script is:inline>

  /** Scrolls the document to the top when
   * the "Back to Top" button is clicked. */
  function backToTop() {
    const rootElement = document.documentElement;
    const btnContainer = document.querySelector("#btt-btn-container");
    const backToTopBtn = document.querySelector("[data-button='back-to-top']");

    if (!rootElement || !btnContainer || !backToTopBtn) return;

    // Attach click event handler for back-to-top button
    backToTopBtn.addEventListener("click", () => {
      // 优先使用平滑滚动
      if ("scrollTo" in window) {
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else {
        // 回退方案
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
      }
    });

    // Handle button visibility according to scroll position
    let lastVisible = null;
    function handleScroll() {
      const windowHeight = window.screen.height;
      const scrollTop = rootElement.scrollTop;

      const isVisible = scrollTop > windowHeight / 2;

      if (isVisible !== lastVisible) {
        btnContainer.classList.toggle("opacity-100", isVisible);
        btnContainer.classList.toggle("translate-y-0", isVisible);
        btnContainer.classList.toggle("visible", isVisible);
        btnContainer.classList.toggle("opacity-0", !isVisible);
        btnContainer.classList.toggle("translate-y-14", !isVisible);
        btnContainer.classList.toggle("invisible", !isVisible);
        lastVisible = isVisible;
      }
    }

    let ticking = false;
    document.addEventListener("scroll", () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    });
  }

  /** 防止回顶按钮与目录按钮遮挡 */
  function positionAdjustment() {
    const bttButton = document.getElementById("btt-btn-container");
    if (!bttButton) return;

    const mobileFloatMenu = document.getElementById("mobile-toc-float");

    // 基于移动端浮动目录容器的 class 状态判断：expanded 表示展开可见，minimized 表示最小化
    function shouldBttDisplay() {
      if (!!mobileFloatMenu && mobileFloatMenu.classList.contains("mobileFloatHidden")) {
        return false;
      }
      return (
        !!mobileFloatMenu && mobileFloatMenu.classList.contains("minimized")
      );
    }

    const tocVisible = shouldBttDisplay();
    // 将状态写到全局，避免未声明变量报错
    try {
      // @ts-ignore
      window.bttDown = !tocVisible;
    } catch {}

    // 根据可见性切换 bottom 间距，right 始终为 right-5
    bttButton.classList.toggle("bottom-24", tocVisible);
    bttButton.classList.toggle("bottom-5", !tocVisible);
  }
  
  backToTop();

  window.addEventListener("resize", () => positionAdjustment());

  // 监听移动目录容器的 class/style 变化，以便及时调整位置
  // 抽出可重入初始化，便于在页面切换后重新绑定
  function setupMobileTocObserver() {
    // 断开旧的观察器，避免引用旧节点
    // @ts-ignore
    if (window.__bttMO && typeof window.__bttMO.disconnect === "function") {
      // @ts-ignore
      window.__bttMO.disconnect();
    }

    const mobileFloat = document.getElementById("mobile-toc-float");
    if (mobileFloat && "MutationObserver" in window) {
      const mo = new MutationObserver(() => positionAdjustment());
      mo.observe(mobileFloat, {
        attributes: true,
        attributeFilter: ["class", "style", "hidden"],
      });
      // @ts-ignore
      window.__bttMO = mo;
    }

    // 立即调整一次，确保状态正确
    positionAdjustment();
  }

  // 初始化一次
  setupMobileTocObserver();

  // 页面切换（Astro 过渡）后重新绑定并调整
  document.addEventListener("astro:page-load", setupMobileTocObserver);
  document.addEventListener("astro:after-swap", setupMobileTocObserver);
</script>
