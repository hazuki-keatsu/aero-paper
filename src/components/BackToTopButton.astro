---
import IconChevronLeft from "@/assets/icons/IconChevronLeft.svg";
---

<!-- 回到顶部按钮（样式参考 MusicPlayer 最小化按钮） -->
<div
  id="btt-btn-container"
  transition:persist="back-to-top"
  class="fixed bottom-24 right-5 z-40 transition-all duration-200 ease-in-out opacity-0 translate-y-14"
>
  <button
    type="button"
    data-button="back-to-top"
    aria-label="返回顶部"
    class="content-card group flex items-center justify-center cursor-pointer rounded-xl transition-all duration-200 hover:bg-accent/20"
    style="width: 3.5rem; height: 3.5rem;"
  >
    <IconChevronLeft
      aria-hidden="true"
      class="text-accent transition-transform duration-200 group-hover:scale-110 rotate-90"
      style="width: 1.5rem; height: 1.5rem;"
    />
  </button>
  
</div>

<script is:inline>
  /** Scrolls the document to the top when
   * the "Back to Top" button is clicked. */
  function backToTop() {
    const rootElement = document.documentElement;
    const btnContainer = document.querySelector("#btt-btn-container");
    const backToTopBtn = document.querySelector("[data-button='back-to-top']");

    if (!rootElement || !btnContainer || !backToTopBtn)
      return;

    // Attach click event handler for back-to-top button
    backToTopBtn.addEventListener("click", () => {
      // 优先使用平滑滚动
      if ("scrollTo" in window) {
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else {
        // 回退方案
        document.body.scrollTop = 0; // For Safari
        document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
      }
    });

    // Handle button visibility according to scroll position
    let lastVisible = null;
    function handleScroll() {
      const windowHeight = window.screen.height;
      const scrollTop = rootElement.scrollTop;

      const isVisible = scrollTop > windowHeight / 2;

      if (isVisible !== lastVisible) {
        btnContainer.classList.toggle("opacity-100", isVisible);
        btnContainer.classList.toggle("translate-y-0", isVisible);
        btnContainer.classList.toggle("visible", isVisible);
        btnContainer.classList.toggle("opacity-0", !isVisible);
        btnContainer.classList.toggle("translate-y-14", !isVisible);
        btnContainer.classList.toggle("invisible", !isVisible);
        lastVisible = isVisible;
      }
    }

    let ticking = false;
    document.addEventListener("scroll", () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    });
  }

  /** 防止回顶按钮与目录按钮遮挡 */
  function positionAdjustment() {
    const bttButton = document.getElementById("btt-btn-container");
    if (!bttButton) return;

    const tocButton = document.getElementById("toc-button");

    // 更稳健的“可见性”判断：
    // 1) 自身与视口有交集且尺寸>0
    // 2) 自身或任一祖先不存在 display:none / visibility:hidden / opacity≈0 的情况
    function isElementVisible(el) {
      if (!el || !el.isConnected) return false;

      const rect = el.getBoundingClientRect();
      const vw = window.innerWidth || document.documentElement.clientWidth || 0;
      const vh = window.innerHeight || document.documentElement.clientHeight || 0;
      const intersectsViewport =
        rect.width > 0 &&
        rect.height > 0 &&
        rect.bottom > 0 &&
        rect.right > 0 &&
        rect.top < vh &&
        rect.left < vw;
      if (!intersectsViewport) return false;

      // 检查自身及祖先的显示状态（处理父级 opacity:0 / visibility:hidden 等）
      let node = el;
      while (node && node !== document.documentElement) {
        const s = window.getComputedStyle(node);
        if (s.display === "none" || s.visibility === "hidden" || parseFloat(s.opacity || "1") <= 0.05) {
          return false;
        }
        node = node.parentElement;
      }

      return true;
    }

    const tocVisible = isElementVisible(tocButton);
    console.log("Toc可见状态：" + tocVisible);

    // 根据可见性切换 bottom 间距，right 始终为 right-5
    bttButton.classList.toggle("bottom-24", tocVisible);
    bttButton.classList.toggle("bottom-5", !tocVisible);
  }

  positionAdjustment();
  backToTop();

  window.addEventListener("resize", () => positionAdjustment());

  // 监听移动目录容器的 class/style 变化，以便及时调整位置
  const mobileFloat = document.getElementById("mobile-toc-float");
  if (mobileFloat && "MutationObserver" in window) {
    const mo = new MutationObserver(() => positionAdjustment());
    mo.observe(mobileFloat, { attributes: true, attributeFilter: ["class", "style"] });
  }

  // 页面切换（Astro 过渡）后也重新计算
  document.addEventListener("astro:page-load", positionAdjustment);
  document.addEventListener("astro:after-swap", positionAdjustment);
</script>
